{
  long startTime=System.nanoTime();
  ArrayList<KafkaMessageId> emittedIds=emitFailedTuples(collector);
  ByteBufferMessageSet waitingToEmit=fetchMessageFromKafka(currentKafkaOffset.get());
  if (!waitingToEmit.iterator().hasNext()) {
    zeroEmits.incr();
    return emittedIds;
  }
  for (  MessageAndOffset messageAndOffset : waitingToEmit) {
    byte[] payload=Utils.toByteArray(messageAndOffset.message().payload());
    long offset=messageAndOffset.offset();
    if (!applyPayloadFilter(payload)) {
      Iterable<List<Object>> tuples=deserializePayload(payload,offset);
      if (tuples != null) {
        for (        List<Object> tuple : tuples) {
          updateLatestEmittedTupleTimestamp(tuple);
          if (!applyTupleFilter(tuple)) {
            emittedIds.add(emitMessage(tuple,currentKafkaOffset.get(),collector));
          }
        }
      }
    }
    currentKafkaOffset.set(offset);
  }
  long endTime=System.nanoTime();
  nsInNext.incrBy(endTime - startTime);
  return emittedIds;
}
