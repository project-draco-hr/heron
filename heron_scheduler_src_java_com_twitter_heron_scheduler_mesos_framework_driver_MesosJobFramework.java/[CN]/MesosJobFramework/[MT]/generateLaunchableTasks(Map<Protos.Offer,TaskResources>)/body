{
  List<LaunchableTasks> tasks=new LinkedList<>();
  Set<String> taskIds=new HashSet<>();
  while (!pendingScheduleTasks.isEmpty()) {
    String taskId=pendingScheduleTasks.poll();
    BaseJob job=jobNameMapping.get(TaskUtils.getJobNameForTaskId(taskId));
    BaseTask task=trackingTasks.get(job.name);
    if (task != null && task.state.equals(BaseTask.TaskState.SCHEDULED)) {
      LOG.info("Found job in queue that is already scheduled and running for launch: " + job.name);
    }
 else {
      if (taskIds.contains(taskId)) {
        LOG.info("Found job in queue that is already scheduled for launch with this offer set: " + job.name + "\n");
      }
 else {
        TaskResources neededResources=new TaskResources(job);
        Iterator<Map.Entry<Protos.Offer,TaskResources>> it=offerResources.entrySet().iterator();
        while (it.hasNext()) {
          Map.Entry<Protos.Offer,TaskResources> kv=it.next();
          Protos.Offer offer=kv.getKey();
          TaskResources resources=kv.getValue();
          if (resources.canSatisfy(neededResources)) {
            resources.consume(neededResources);
            tasks.add(new LaunchableTasks(taskId,job,offer,(int)(neededResources.portsHold.get(0).rangeStart),(int)(neededResources.portsHold.get(0).rangeEnd)));
            taskIds.add(taskId);
            break;
          }
 else {
            LOG.info(String.format("Insufficient resources remaining for task: %s, will append to queue. Need: [%s], Found: [%s]",taskId,neededResources.toString(),resources.toString()));
            pendingScheduleTasks.add(taskId);
            return tasks;
          }
        }
      }
    }
  }
  return tasks;
}
