{
  LOG.info("Starting reconcile executor.");
  for (  BaseTask task : trackingTasks.values()) {
    BaseTask.TaskState state=task.state;
    if (state.equals(BaseTask.TaskState.SCHEDULED) || state.equals(BaseTask.TaskState.TO_KILL) || state.equals(BaseTask.TaskState.TO_KILL_NOW)) {
      remaining.put(task.taskId,TaskUtils.getMesosTaskStatus(task,Protos.TaskState.TASK_ERROR).build());
    }
  }
  if (!isRecovered && remaining.isEmpty()) {
    LOG.info("No tasks need to reconcile.");
    isRecovered=true;
    if (startLatch != null) {
      startLatch.countDown();
    }
  }
  Runnable r=new Runnable(){
    @Override public void run(){
synchronized (this) {
        if (!remaining.isEmpty()) {
          LOG.info("We are doing explicit reconciliation to recover from failure");
          schedulerDriver.reconcileTasks(remaining.values());
        }
 else {
          LOG.info("We are doing implicit reconciliation to check health periodically");
          schedulerDriver.reconcileTasks(new LinkedList<Protos.TaskStatus>());
        }
        reconcileExecutors.schedule(this,config.reconciliationIntervalInMs,TimeUnit.MILLISECONDS);
      }
    }
  }
;
  reconcileExecutors.schedule(r,0,TimeUnit.MILLISECONDS);
}
