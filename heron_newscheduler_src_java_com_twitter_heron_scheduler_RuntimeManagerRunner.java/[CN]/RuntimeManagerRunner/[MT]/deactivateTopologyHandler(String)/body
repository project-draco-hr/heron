{
  TopologyAPI.TopologyState state=getRuntimeTopologyState(topologyName);
  if (state == null) {
    LOG.severe("Topology still not initialized.");
    return false;
  }
  if (state == TopologyAPI.TopologyState.PAUSED) {
    LOG.warning("Topology is already deactivated");
    return true;
  }
  if (!runtimeManager.prepareDeactivate()) {
    LOG.severe("Failed to prepare deactivate locally");
    return false;
  }
  final HttpURLConnection connection=createHttpConnection();
  if (connection == null) {
    return false;
  }
  try {
    byte[] data=Scheduler.DeactivateTopologyRequest.newBuilder().setTopologyName(topologyName).build().toByteArray();
    if (!HttpUtils.sendHttpPostRequest(connection,data)) {
      LOG.log(Level.SEVERE,"Failed to send http request for deactivate");
      return false;
    }
    Common.StatusCode statusCode;
    LOG.info("Receiving deactivate response from scheduler...");
    statusCode=Scheduler.DeactivateTopologyResponse.newBuilder().mergeFrom(HttpUtils.readHttpResponse(connection)).build().getStatus().getStatus();
    if (!statusCode.equals(Common.StatusCode.OK)) {
      LOG.severe("Received not OK response from scheduler for deactivate");
      return false;
    }
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,"Failed to deactivate with Scheduler: ",e);
    return false;
  }
 finally {
    connection.disconnect();
  }
  if (!runtimeManager.postDeactivate()) {
    LOG.severe("Failed in post deactivate locally");
    return false;
  }
  LOG.info("Scheduler deactivated topology successfully.");
  return true;
}
