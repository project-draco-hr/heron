{
  if (!runtimeManager.prepareKill()) {
    LOG.severe("Failed to prepare kill locally");
    return false;
  }
  Pair<Boolean,HttpURLConnection> ret=createHttpConnection();
  if (!ret.first) {
    return false;
  }
  HttpURLConnection connection=ret.second;
  if (connection != null) {
    try {
      byte[] data=Scheduler.KillTopologyRequest.newBuilder().setTopologyName(topologyName).build().toByteArray();
      if (!HttpUtils.sendHttpPostRequest(connection,data)) {
        LOG.log(Level.SEVERE,"Failed to send http request for kill");
        return false;
      }
      Common.StatusCode statusCode;
      try {
        LOG.info("Receiving kill response from scheduler...");
        statusCode=Scheduler.KillTopologyResponse.newBuilder().mergeFrom(HttpUtils.readHttpResponse(connection)).build().getStatus().getStatus();
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,"Failed to parse kill response: ",e);
        return false;
      }
      if (!statusCode.equals(Common.StatusCode.OK)) {
        LOG.severe("Received not OK response from scheduler for kill");
        return false;
      }
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,"Failed to kill with Scheduler: ",e);
      return false;
    }
 finally {
      connection.disconnect();
    }
  }
  if (!runtimeManager.postKill()) {
    LOG.severe("Failed in post deactivate locally");
    return false;
  }
  if (!cleanState(topologyName)) {
    LOG.severe("Failed in clean state");
    return false;
  }
  LOG.info("Scheduler killed topology successfully.");
  return true;
}
